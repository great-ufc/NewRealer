//------Generated by the Framework and must be changed-----//
//------Analysis Module Main Class-----//

package br.ufc.realer_2.model.mapek.analysis

import android.util.Log
import br.ufc.realer_2.model.entities.*
import br.ufc.realer_2.model.mapek.knowledge.KnowledgeManagement
import br.ufc.realer_2.model.mapek.monitoring.CollectEnergy
import br.ufc.realer_2.model.mapek.observer.IAnalysisObservable
import br.ufc.realer_2.model.mapek.observer.IAnalysisObserver
import br.ufc.realer_2.model.mapek.observer.IMonitorObserver
import br.ufc.realer_2.model.mapek.planning.PlanningRolesManagement
import br.ufc.realer_2.ui.CommonActivities.BaseActivity

class DataAnalysis(val context:BaseActivity):IMonitorObserver,IAnalysisObservable {

    override val observers: MutableList<IAnalysisObserver> = mutableListOf()
    private val contextList:MutableList<Context> = mutableListOf<Context>()
    private val myFeatures:MutableList<VerticeFeature> = mutableListOf<VerticeFeature>()
    //contextos considerados

    fun setContextList(energy:Double){
        if(contextList == null || contextList.size == 0){
            val battery = Context("Battery", energy);
            contextList += battery;
        }else{
            for(context in contextList){
                if (context.name == "Battery")
                    context.value = energy;
            }
        }
    }

    fun setFeatureList(features:MutableList<VerticeFeature>){
        myFeatures.clear()
        myFeatures += features
    }

    fun featureAnalysis(){

        //obtém base de conhecimento

        val knowledgeRepresentation:KnowledgeRepresentation = context.knowledgeManagement
                                                                          .knowledgeManager(myFeatures);

        //Faz a análise
        var finalResult:ResultEntry = KnowLedgeAnalysis(contextList, knowledgeRepresentation);

        //Observer pattern
        for(observer in observers){
            //Intancia o Gerenciador de Regras
            val planningRolesManagement = observer as PlanningRolesManagement
            planningRolesManagement.changeContext = CurrentContextManager(contextList, planningRolesManagement)
            planningRolesManagement.resultEntry = finalResult

        }
        sendUpdateEvent()
    }

    //Houve mudança de contexto que demanda adaptação
    fun CurrentContextManager(listContext:MutableList<Context>, planRoles: PlanningRolesManagement):Boolean{
        if(context.actions == null)
            return true;
        if(context.actions.size == 0)
            return true;
        else {
            //Verifica contextos
            //Ler regras
            //val adaptationRules:AdaptationRules = ReadAdaptationXML.readXML();
            val actions = planRoles.ChoiceActions(contextList)

            //Verifica se o número de ações atuais e novas é o mesmo baseada nas regras
            if(actions.size != context.actions.size)
                return true;

            //verifica se ações mudaram baseada nas regras
            for (currentaction in context.actions ){
                if(!actions.contains(currentaction))
                    return true;
            }

            return false;
        }
    }

    fun KnowLedgeAnalysis(listContext:MutableList<Context>, knowledgeRepresentation:KnowledgeRepresentation ):ResultEntry{
        var finalStatus:String = ""
        var maxModelProbability:Double = 0.0
        var batteryValueFlow:Double = 0.0

        var sensorName:String = "";
        for (e:EdgeSensorFeature in knowledgeRepresentation.edgeSensorFeature){
            if(sensorName != e.vSensor.typeSensor){
                if(e.contexts != null)
                    batteryValueFlow += e.contexts[0].value as Double
            }
        }

        //Get Features battery energy
        var featureNames: MutableList<String> = mutableListOf<String>()
        for (e:EdgeFeatureModel in knowledgeRepresentation.edgeFeaturesModel){
            if(!featureNames.contains(e.vFeature.featureName.name)) {
                batteryValueFlow += e.vFeature.feature as Double
                featureNames.add(e.vFeature.featureName.name)
            }
        }

        if(listContext[0].value as Double > batteryValueFlow){
            var vfs:MutableList<VerticeFinalStatus> = mutableListOf<VerticeFinalStatus>()
            //Encontra todos os caminhos possíveis, considerando também o contexto
            var modelNames:MutableList<Pair<VerticeModel,Double>> = mutableListOf<Pair<VerticeModel,Double>>();
            var auxModelName:String? = null
            var auxFinalStatus:VerticeFinalStatus? = null
            var flagNewModel = false
            for (ecf:EdgeModelsFinalStatus in knowledgeRepresentation.edgeModelsFinalStatus)
            {
                if(auxModelName == null || auxModelName != ecf.vModel.modelName){
                    if (auxModelName != null)
                        flagNewModel = true
                    auxModelName = ecf.vModel.modelName
                    modelNames.add(Pair(ecf.vModel,ecf.probability!!))
                }
                if((auxFinalStatus == null || auxFinalStatus!!.finalStatus != ecf.vFinalStatus.finalStatus) && !flagNewModel){
                    auxFinalStatus = ecf.vFinalStatus
                    vfs.add(auxFinalStatus)
                }
            }

            for(modelName in modelNames){
                Log.i("Model:", modelName.first.modelName)
                if(modelName.first.modelName.split(".")[1] == "tflite"){
                    if(maxModelProbability < modelName.second){
                        maxModelProbability = modelName.second
                        finalStatus = KnowledgeManagement.doInference(myFeatures, modelName.first, vfs);
                    }
                }
            }
        }

        return ResultEntry(contextList, maxModelProbability,finalStatus);
    }

    override fun update() {
        setContextList(CollectEnergy().collectEnergy(context));
        setFeatureList(FeatureExtraction(context).featureDataExtraction())

        //Janela de dados
        var i = 0 ;
        val dataWindow = ((2.0/3.0)*context.datas.size).toInt()//Mantém 1/3 dos dados
        while (i < dataWindow) {
            context.datas-=context.datas[context.datas.size-1];
            i++;
        }
        featureAnalysis()
    }

}