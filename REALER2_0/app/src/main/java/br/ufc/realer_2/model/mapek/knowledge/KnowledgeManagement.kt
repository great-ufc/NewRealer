//------Generated by the Framework and must be changed-----//
//------Knowledge Base Management Module Main Class-----//

package br.ufc.realer_2.model.mapek.knowledge


import android.content.res.AssetFileDescriptor
import android.util.Log
import br.ufc.realer_2.model.cloudConnection.KnowledgeDownload
import br.ufc.realer_2.model.entities.*
import br.ufc.realer_2.ui.CommonActivities.BaseActivity
import java.io.FileInputStream
import java.io.IOException
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel


class KnowledgeManagement (val context:BaseActivity) {

    fun knowledgeManager(myfeatures:MutableList<VerticeFeature>): KnowledgeRepresentation {
        ///download dataset
        if(context.knowledgeRepresentation == null) {
            context.knowledgeRepresentation  = datasetUpdate(myfeatures)
        }

        return context.knowledgeRepresentation!!
    }

    //download from cloud
    private fun datasetUpdate(myFeatures: MutableList<VerticeFeature>): KnowledgeRepresentation {
        var knowledgeRepresentation = KnowledgeRepresentation(  mutableListOf(),
                                                                mutableListOf(),
                                                                mutableListOf())


        //read downloaded KnowledgeRepresentation
        //from cloud

        knowledgeRepresentation = KnowledgeDownload.update(myFeatures, context)

        //for local test
        //knowledgeRepresentation = buildlocalKnowledgeRepresentationLocal(knowledgeRepresentation, myFeatures)

        return knowledgeRepresentation
    }


    //init ml model tflite
    @Throws(IOException::class)
    private fun loadModelFile(fileDescriptor: AssetFileDescriptor): MappedByteBuffer {
        val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
        val fileChannel: FileChannel = inputStream.channel
        val startOffset = fileDescriptor.startOffset
        val declaredLenght = fileDescriptor.declaredLength
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLenght)
    }

      companion object {
          
    //for local test
          fun buildlocalKnowledgeRepresentationLocal(
              knowledgeRepresentation: KnowledgeRepresentation,
              myFeatures: MutableList<VerticeFeature>
          ): KnowledgeRepresentation {
              val vsensor = VerticeSensor("ACC")
              val lstVfeature: MutableList<VerticeFeature> = mutableListOf()
              for (feat in myFeatures) {
                  lstVfeature.add(VerticeFeature(feat.feature, feat.featureName))
              }
              val vmodel = VerticeModel("modelForLocalTest.tflite", 18, 17)

              //public List<EdgeSensorFeature> edgeSensorFeatureList;
              val lstESensorFeatures: MutableList<EdgeSensorFeature> = mutableListOf()
              for (vf in lstVfeature) {
                  val edgesf = EdgeSensorFeature(vsensor,vf)
                  lstESensorFeatures.add(edgesf)
              }

              //public List<EdgeFeturesModel> edgeFeturesModelList;
              val lstEFeturesModel: MutableList<EdgeFeatureModel> = mutableListOf()
              for (vf in lstVfeature) {
                  val edgefm = EdgeFeatureModel(vf,vmodel)
                  lstEFeturesModel.add(edgefm)
              }

              //Final Status
              val lstVerticeFinalStatus: MutableList<VerticeFinalStatus> = mutableListOf()
              lstVerticeFinalStatus.add(VerticeFinalStatus("Andar"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("BATER_NA_MESA"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("BATER_PAREDE"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("CORRENDO"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("DEITAR"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("ESBARRAR_PAREDE"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("ESCREVER"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("PALMAS_EMP"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("PALMAS_SEN"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("PULO"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("QUEDA_APOIO_FRENTE"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("QUEDA_LATERAL"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("QUEDA_SAPOIO_FRENTE"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("SENTAR"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("SENTAR_APOIO"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("SENTAR_SAPOIO"))
              lstVerticeFinalStatus.add(VerticeFinalStatus("TATEAR"))

              //public List<EdgeModelsFinalStatus> edgeModelsFinalStatusList;
              val lstEModelsFinalStatus: MutableList<EdgeModelsFinalStatus> = mutableListOf()
              for (vfs in lstVerticeFinalStatus) {
                  val edgemf = EdgeModelsFinalStatus(vmodel,vfs, 80.0)
                  lstEModelsFinalStatus.add(edgemf)
              }

              knowledgeRepresentation.edgeFeaturesModel = lstEFeturesModel
              knowledgeRepresentation.edgeModelsFinalStatus = lstEModelsFinalStatus
              knowledgeRepresentation.edgeSensorFeature = lstESensorFeatures
              return knowledgeRepresentation
          }

          fun doInference(lstFeatures:MutableList<VerticeFeature>?, vmodel:VerticeModel, vfinalStatus:MutableList<VerticeFinalStatus>):String{
            //Trained Model (tensorflow lite)
            val tflite = vmodel.model
            //Inner
            val input = FloatArray(vmodel.inFeature)

            //features

            ///////how identificate features inexistence? Think about/////


            //features
            for (i in 0 until lstFeatures!!.size) {
                try{
                    input[i] = lstFeatures[i].feature.toFloat()
                }catch (e:java.lang.Exception){
                    Log.i("OutRange",lstFeatures!!.size.toString())
                }
            }

            val output = Array(1) {
                  FloatArray(
                    vmodel.outFeature
                )
            }
            tflite!!.run(input, output)


            ///Return finalstatus after inference
            //finalstatus represent the status with the biggest probability value
            var vMax = -9999.0f
            var pos = -1
            for (i in 0 until output[0].size) {
                if (output[0][i] > vMax) {
                    vMax = output[0][i]
                    pos = i
                }
            }

            return vfinalStatus[pos].finalStatus
        }
     }

    //Optional method for upload data to classification graph system on cloud server
    fun datasetUpload() {}
}
